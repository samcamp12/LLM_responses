Below is a concise, copy‑pasteable playbook you can keep in your repo (e.g., `docs/prompting.md`). It’s optimized for React + TypeScript work.

## 1) Quickstart Formula (use this in any prompt)

**ROLE → GOAL → CONTEXT → CONSTRAINTS → OUTPUT → CHECKS**

* **ROLE:** Who the assistant/agent should be.
* **GOAL:** Single, measurable outcome.
* **CONTEXT:** Files, snippets, error, environment, what you tried.
* **CONSTRAINTS:** Libraries, style rules, performance/a11y targets, file boundaries.
* **OUTPUT:** Exact shape (diff, code block per file, checklist, short rationale).
* **CHECKS:** Tests to pass, acceptance criteria, edge cases.

> **One‑liner version:**
> *“Act as a Senior React+TS engineer. Goal: fix X. Context: [code/error]. Constraints: keep public API, pass tests, adhere to ESLint/Prettier. Output: a unified diff + brief rationale. Checks: list edge cases and how covered.”*

---

## 2) One‑Time “Project Card” (paste at top of a new thread)

Fill this out once and reuse it. Trim anything irrelevant.

```text
PROJECT
- App type: <SPA | Next.js SSR/ISR | Electron | RN Web>
- Core: React <version>, TypeScript <version>, Node <version>
- State/data: <Zustand/Redux/TanStack Query/RTK Query/...>
- Routing: <React Router v6 | Next.js App Router>
- Styling: <CSS Modules | Tailwind | styled-components | MUI | Chakra>
- Build: <Vite | Next.js | Webpack>, target browsers: <browserslist>
- Tests: <Vitest/Jest>, E2E: <Playwright/Cypress>, UI: <React Testing Library>
- Lint/format: <ESLint config>, <Prettier config>
- Design System: <Storybook?> <tokens?>
- Perf budgets: <LCP < 2.5s on 4G, bundle < 200KB gz>, critical path>
- a11y: <WCAG 2.1 AA>, i18n: <library?>
- Repo rules: Conventional Commits, required checks: <list>
- Don’t touch: <files/dirs>, Secrets in .env (never paste).
```

---

## 3) What to include (by problem type)

**Bugs**

* Exact error text and stack (verbatim), screenshot if UI.
* Minimal repro (smallest component or hook reproducing the issue).
* Steps to reproduce + what you already tried.

**TypeScript**

* The precise types/interfaces involved, `tsconfig.json` flags that matter (`strict`, `noUncheckedIndexedAccess`, etc.).
* Expected vs. actual types; show failing line annotations.

**React performance**

* What’s slow (interaction/LCP/TTI), how measured (React Profiler numbers, timings).
* Where state lives, memoization strategy, and component tree slice.

**Build/Bundle**

* Current chunk sizes, dynamic import boundaries, relevant config (Vite/Next/webpack).
* Third‑party libs involved and why they must remain.

**Accessibility**

* Desired UX (keyboard flow, roles, announcements).
* Screenshots/DOM snapshot + current ARIA attributes.

**Tests**

* Test intent (“what behavior proves this works”), current failures, any flakiness notes.

---

## 4) Output Contracts to request (pick 1–2 max)

* **Unified diff only:** “Return a single unified diff touching only files I list.”
* **File‑per‑block:** “For each file, one fenced code block with `title="path"`.”
* **Rationale cap:** “Explain decisions in ≤7 bullets—trade‑offs only.”
* **Checklists:** “End with a ‘Done when’ checklist & risks.”
* **No drive‑by edits:** “If unsure, ask up to 3 clarifying questions before modifying unrelated code.”

---

## 5) Agent Task Card (use for autonomous repo changes)

Paste this YAML in your Agent prompt and fill the blanks:

```yaml
task: "<imperative objective—ship a small, testable change>"
scope:
  include: ["src/components/Button.tsx", "src/hooks/useX.ts"]
  exclude: ["src/legacy/**", "scripts/release/**"]
constraints:
  - Keep public APIs backward compatible
  - Preserve existing tests; add new tests for new paths
  - Follow ESLint/Prettier; file headers unchanged
  - Don’t introduce new deps without approval
acceptance_criteria:
  - All unit/integration tests pass locally (command: "pnpm test")
  - Lint & typecheck clean ("pnpm lint", "pnpm typecheck")
  - Bundle delta < +10KB gzip in main route
  - Keyboard + screen reader flow unchanged unless specified
io:
  input_artifacts:
    - short_context: "Why we need this"
    - evidence: ["error log", "profiler screenshot", "failing test"]
  output_artifacts:
    - patch: "unified diff"
    - rationale: "bulleted trade-offs"
    - tests: "added/updated test files"
repo:
  branch: "feat/<slug>"
  commit_convention: "conventional commits"
plan:
  require_approval: true  # Agent proposes a plan, waits for “approve” before changes
security:
  - Never print secrets or .env values
  - Don’t send large code outside listed scope
```

---

## 6) Reusable Prompt Templates (tailored for React + TS)

### A) Bug‑fix (component/hook)

````
ROLE: Senior React+TS engineer.
GOAL: Diagnose and fix the bug where <symptom>.
CONTEXT: <error text> ; files: <paths>; minimal repro:
```tsx title="src/Example.tsx"
// ...
````

CONSTRAINTS: Keep public API; no new deps; follow existing patterns.
OUTPUT: Unified diff + ≤7‑bullet rationale; include tests proving the fix.
CHECKS: List edge cases; explain why they’re covered.

```

### B) Implement a component from a spec
```

ROLE: Design‑system aware React engineer.
GOAL: Build <ComponentName> with <behaviors>.
CONTEXT: Screen/UX notes (breakpoints, focus order, ARIA), tokens, DS primitives.
CONSTRAINTS: A11y first (WCAG 2.1 AA); SSR‑safe; no layout shift on mount.
OUTPUT: File‑per‑block code; story in Storybook; tests (RTL).
CHECKS: Include manual test script (tab/shift+tab, screen reader announce points).

```

### C) Type inference help
```

ROLE: TypeScript expert.
GOAL: Derive a type that enforces <rule>, given these values/functions.
CONTEXT: tsconfig flags + current types; smallest failing snippet.
CONSTRAINTS: No `any`; prefer distributive conditional types.
OUTPUT: Minimal type alias + explanation of why it narrows correctly.
CHECKS: Show a tiny “should compile / should error” pair.

```

### D) Performance remediation
```

ROLE: React performance engineer.
GOAL: Reduce re‑renders and TTI in <component/route>.
CONTEXT: Profiler summary (commit times, flame chart hotspots), state location diagram.
CONSTRAINTS: No visible UX regressions; don’t change data contract.
OUTPUT: Diff + before/after metrics table; list memoization and cache boundaries.
CHECKS: Explain why changes are stable under concurrent rendering.

```

### E) Test authoring
```

ROLE: Testing engineer (RTL + Playwright/Cypress).
GOAL: Add tests that prove <behavior>.
CONTEXT: Component or page code; current failing tests; flake notes.
CONSTRAINTS: Stable selectors, avoid implementation details.
OUTPUT: Test files + fixtures + brief rationale; commands to run.
CHECKS: Failure message that would catch regressions.

```

### F) Migration/refactor (safe & scoped)
```

ROLE: Senior engineer focused on incremental refactors.
GOAL: Migrate <X to Y> / Refactor <module> with zero behavior change.
CONTEXT: Current file(s) + public API list; integration points.
CONSTRAINTS: No mass renames; keep exports stable; add codemod if helpful.
OUTPUT: Small, reviewable diff; list risk areas + quick rollback plan.
CHECKS: Confidence checklist (types, tests, perf, a11y).

```

---

## 7) Filled Example (short)
> **Prompt:**  
> ROLE: Senior React+TS engineer.  
> GOAL: Fix “Cannot read properties of undefined (reading 'map')” when switching tabs.  
> CONTEXT: Happens in `src/pages/Orders.tsx` after `useQuery` refetch. Minimal repro below. Error stack + component snippet included.  
> CONSTRAINTS: No behavior change; keep API; no new deps.  
> OUTPUT: Unified diff + ≤5 bullets rationale; add a unit test.  
> CHECKS: Cover empty states, loading states, slow network.

Why this works: it states the goal, pinpoints the file, provides a repro, and nails output + checks—so the answer you get is a focused patch plus tests.

---

## 8) Handy “Shortcodes” you can add to any prompt
- **[DIFF]** return unified diff only; fail if touching other files.  
- **[BRIEF]** limit rationale to 5–7 bullets (no verbose step‑by‑step).  
- **[STRICT]** follow ESLint/Prettier and `tsconfig` strictly; no `// @ts-ignore`.  
- **[A11Y]** include ARIA roles/labels and keyboard script.  
- **[PERF]** include before/after numbers and why they’re stable.  
- **[TEST]** include Jest/Vitest + RTL tests for new/changed logic.  
- **[PLAN]** propose a plan first; wait for my “approve” keyword.  
- **[SCOPE:<paths>]** only touch listed files.

Example:  
“Fix the tab crash [DIFF][BRIEF][TEST][SCOPE:src/pages/Orders.tsx,src/hooks/useOrders.ts].”

---

## 9) Guardrails & good hygiene
- **Never paste secrets** (`.env`, API keys, customer data). If an agent needs them, use env vars locally.  
- **Keep diffs small** (≤200 lines) and focused; ask the agent to split work if larger.  
- **Prefer minimal repros**—strip unrelated code and cut props down.  
- **Lock the output**—be explicit about file names, formats, and commit style.  
- **Bias to existing patterns**—ask the answer to match current project conventions.  
- **Ask for failure modes**—“list 3 ways this could break and how we mitigated them.”

---

### Copy‑paste Checklists

**Bug prompt checklist**
- [ ] Error text + stack (verbatim)  
- [ ] Minimal repro snippet  
- [ ] Steps to reproduce  
- [ ] Files/paths involved  
- [ ] What you tried  
- [ ] Output format + tests requested

**Feature prompt checklist**
- [ ] UX spec + states (idle/loading/empty/error)  
- [ ] A11y/keyboard/ARIA expectations  
- [ ] Responsive rules/breakpoints  
- [ ] Data contract (types)  
- [ ] Output format (code blocks or diff)  
- [ ] Acceptance criteria

---

Below is a no‑nonsense guide tuned for a mid‑senior React/TypeScript developer. Keep it handy in your repo as `docs/prompt-rules.md`.

## The 10 Rules (TL;DR)

1. **State a single, testable goal.**
   Bad: “Optimize performance.”
   Good: “Reduce re‑renders of `OrderList` when filters change; target < 30ms commit time in React Profiler.”

2. **Pin versions & environment.**
   Include: `React 18.3`, `TypeScript 5.4`, `Vite 5`, `Node 20`, `React Router v6.28`, browser targets. (Version drift invites invented APIs.)

3. **Provide a minimal, runnable slice.**
   Share the smallest component/hook + exact error text + repro steps. Omit surrounding app noise.

4. **Show types and data shapes.**
   Paste relevant interfaces, example payloads, and the failing line. TS without types = guesswork.

5. **Set constraints and acceptance criteria.**
   “No new deps; keep public API stable; pass `pnpm test && pnpm typecheck`; a11y unchanged; diff only in `src/components/Table/*`.”

6. **Specify the output format.**
   Ask for **a unified diff**, or **one code block per file** with `title="path"`, plus **≤7 bullet rationale** and **tests**.

7. **Limit scope aggressively.**
   Name the files the model may touch. Hallucinations often appear when the scope is “the whole app.”

8. **Prefer facts to adjectives.**
   Replace “cleaner, better, nicer” with explicit metrics, APIs, keyboard flows, ARIA roles, breakpoints.

9. **Allow “I don’t know.”**
   Say: “If information is missing, list the unknowns and stop—do not invent APIs or behavior.”

10. **For anything that changes over time, require sources.**
    “If library APIs are referenced, cite official docs and include versioned links.” (Prevents made‑up methods.)

---

## What to Include (Precision Boosters)

* **Context block (short):**

  * Framework/build: Next.js (App Router?) or Vite, SSR?
  * State/data: TanStack Query/Redux/Zustand.
  * Styling: Tailwind, CSS Modules, MUI, etc.
  * Tooling: ESLint config highlights (`noUncheckedIndexedAccess`, `strictNullChecks`), test runner.
* **Exact error text** and stack **verbatim**.
* **Minimal repro** (component/hook) and **steps to reproduce**.
* **Relevant types** and **example data** (happy path + edge).
* **Constraints** (no new deps, public API frozen, coding style to mimic).
* **Acceptance criteria** (tests pass, bundle delta, perf budget, a11y flow).
* **Output contract** (diff/files, tests, brief rationale, risks list).
* **Scope** (allowlist paths; blacklist legacy dirs).
* **If asking for performance**: Profiler numbers, flame hotspot, render count.
* **If asking for a11y**: Desired focus order, roles, announcements, keyboard script.

> **Paste-able header you can reuse**
>
> ```
> ROLE: Senior React+TS engineer.
> GOAL: <single measurable outcome>.
> STACK: React <v>, TS <v>, <Vite/Next> <v>, <Router/State libs>.
> CONTEXT: <minimal code + error + steps>.
> CONSTRAINTS: <deps, API stability, style, file scope>.
> OUTPUT: <diff or file-per-block> + tests + ≤7 bullets rationale.
> CHECKS: <tests/metrics/a11y to verify>.
> ```

---

## What Causes Hallucinations (Triggers to Avoid)

* **Vague goals** (“improve UX”, “make faster”) with no metrics.
* **Unpinned or ambiguous libraries** (“React Router” without version; “Next routing” without App vs Pages router).
* **Missing code/context** (“complete this feature” but no types, no data contract, no UI states).
* **Forcing certainty** (“don’t ask questions,” “be confident”), which incentivizes guessing.
* **Requesting undocumented or future features** (“use the new TS 6 feature…”) or mixing frameworks incorrectly.
* **Conflicting constraints** (e.g., “no behavior change” + “rewrite to server components”).
* **Giant scopes** (multi‑file refactors across the app in one shot).
* **Asking for chain‑of‑thought** or step‑by‑step internal reasoning.
  Instead ask for a **brief rationale** and **assumptions list**—it’s enough for review without encouraging invented details.
* **No stop condition** for agents (“keep improving the codebase”), leading to speculative edits.

---

## Safer Prompt Patterns (Anti‑Hallucination Guards)

* **Unknowns first:** “Start with an ‘Unknowns & Assumptions’ list. If unknowns block correctness, stop and ask up to 3 questions.”
* **Anchors:** “Only use APIs present in the provided code or official docs for React 18.3/TS 5.4. If absent, propose stubs instead of inventing imports.”
* **Scope gate:** “Touch only: `src/components/Table.tsx`, `src/hooks/useOrders.ts`. Fail if editing outside.”
* **Evidence‑based claims:** “When citing a library API, name the import path and show a 3–5 line usage snippet.”
* **No placeholders:** “No `TODO`, no `any`, no pseudo‑code; provide compilable TS and tests.”
* **Plan‑then‑apply (for agents):** “Propose a plan; wait for ‘approve’ before writing code. After changes, output diff + tests + risk list.”
* **Deterministic style:** “Follow existing patterns and ESLint/Prettier; no opinionated restructures unless requested.”

---

## Examples (Bad → Good)

**Bug fix**

* **Bad:** “Fix tab crash.”
* **Good:**

  ```
  ROLE: Senior React+TS engineer
  GOAL: Fix “Cannot read properties of undefined (reading 'map')” when switching tabs.
  STACK: React 18.3, TS 5.4, Vite 5, TanStack Query 5.51
  CONTEXT: Repro in `src/pages/Orders.tsx` below + stack. Happens after refetch.
  CONSTRAINTS: No new deps; public API stable; scope to Orders page.
  OUTPUT: Unified diff + one RTL test that covers empty/loading states; ≤7 bullets rationale.
  CHECKS: All tests pass; no extra renders (<= 2 per tab switch).
  ```

**Component implementation**

* **Bad:** “Build a dropdown.”
* **Good:**

  ```
  GOAL: Build <Select> with typeahead and keyboard support.
  UX STATES: idle/loading/empty/error; highlight on arrow keys; Enter selects; Esc closes.
  A11Y: role="combobox", aria-expanded, aria-activedescendant; announcements on open/close.
  BREAKPOINTS: xs, md behaviors described here: ...
  OUTPUT: Files: src/components/Select.tsx, Select.stories.tsx, Select.test.tsx
  CHECKS: Playwright script steps 1–6 included; WCAG 2.1 AA passes.
  ```

**Type inference**

* **Bad:** “Help with TS generics.”
* **Good:**

  ```
  GOAL: Constrain `pluck<T, K extends keyof T>(...)` so K respects nested optional keys.
  CONTEXT: tsconfig: strict, noUncheckedIndexedAccess; failing snippet below.
  OUTPUT: Minimal type alias + “should compile/should error” examples.
  ```

---

## Agent‑Specific Rules (when letting an agent change your repo)

1. **Task size:** one PR‑sized change (≤200 lines).
2. **Hard boundaries:** include/exclude globs; forbid config/secrets.
3. **Approvals:** plan → your “approve” → diff + tests; no autonomous merging.
4. **Checks in prompt:** exact commands (`pnpm typecheck`, `pnpm test`, `pnpm lint`).
5. **Telemetry:** require a summary of edits, affected modules, and rollback steps.
6. **Stop on uncertainty:** if doc conflicts or API not found, agent must pause and ask.

**Agent task card footer to paste**

```
Stop conditions:
- API not present in repo or official docs → pause.
- Tests failing unrelated areas → revert and report.
- Bundle delta > +10KB gzip → propose alternatives.
```

---

## Quick “Prompt Linter” (run this before you hit Enter)

* [ ] One goal, measurable & testable
* [ ] Versions pinned (React/TS/build/router/state libs)
* [ ] Minimal repro + exact error text
* [ ] Types & sample data included
* [ ] Constraints + acceptance criteria stated
* [ ] Output format locked (diff/files + tests + brief rationale)
* [ ] File scope restricted
* [ ] Invite “unknowns & assumptions” instead of guesses
* [ ] For doc‑dependent tasks, require official‑docs citations
